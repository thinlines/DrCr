/*
	DrCr: Web-based double-entry bookkeeping framework
	Copyright (C) 2022-2025  Lee Yingtong Li (RunasSudo)

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU Affero General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU Affero General Public License for more details.

	You should have received a copy of the GNU Affero General Public License
	along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

use std::collections::HashMap;
use std::fmt::{Debug, Display};

use chrono::NaiveDate;
use downcast_rs::Downcast;
use dyn_clone::DynClone;
use dyn_eq::DynEq;
use dyn_hash::DynHash;

use crate::QuantityInt;

use super::calculator::ReportingGraphDependencies;

// -----------------
// REPORTING CONTEXT

/// Records the context for a single reporting job
pub struct ReportingContext {
	pub eofy_date: NaiveDate,
	pub(crate) step_lookup_fn: HashMap<
		(&'static str, &'static [ReportingProductKind]),
		(ReportingStepTakesArgsFn, ReportingStepFromArgsFn),
	>,
	pub(crate) step_dynamic_builders: Vec<ReportingStepDynamicBuilder>,
}

impl ReportingContext {
	/// Initialise a new [ReportingContext]
	pub fn new(eofy_date: NaiveDate) -> Self {
		Self {
			eofy_date: eofy_date,
			step_lookup_fn: HashMap::new(),
			step_dynamic_builders: Vec::new(),
		}
	}

	/// Register a lookup function
	///
	/// A lookup function generates concrete [ReportingStep]s from a [ReportingStepId].
	pub fn register_lookup_fn(
		&mut self,
		name: &'static str,
		product_kinds: &'static [ReportingProductKind],
		takes_args_fn: ReportingStepTakesArgsFn,
		from_args_fn: ReportingStepFromArgsFn,
	) {
		self.step_lookup_fn
			.insert((name, product_kinds), (takes_args_fn, from_args_fn));
	}

	/// Register a dynamic builder
	///
	/// Dynamic builders are called when no concrete [ReportingStep] is implemented, and can dynamically generate a [ReportingStep]. Dynamic builders are implemented in [super::builders].
	pub fn register_dynamic_builder(&mut self, builder: ReportingStepDynamicBuilder) {
		if !self
			.step_dynamic_builders
			.iter()
			.any(|b| b.name == builder.name)
		{
			self.step_dynamic_builders.push(builder);
		}
	}
}

/// Function which determines whether the [ReportingStepArgs] are valid arguments for a given [ReportingStep]
///
/// See [ReportingContext::register_lookup_fn].
pub type ReportingStepTakesArgsFn = fn(args: &Box<dyn ReportingStepArgs>) -> bool;

/// Function which builds a concrete [ReportingStep] from the given [ReportingStepArgs]
///
/// See [ReportingContext::register_lookup_fn].
pub type ReportingStepFromArgsFn = fn(args: Box<dyn ReportingStepArgs>) -> Box<dyn ReportingStep>;

// -------------------------------
// REPORTING STEP DYNAMIC BUILDERS

/// Represents a reporting step dynamic builder
///
/// See [ReportingContext::register_dynamic_builder].
pub struct ReportingStepDynamicBuilder {
	pub name: &'static str,
	pub can_build: fn(
		name: &'static str,
		kind: ReportingProductKind,
		args: &Box<dyn ReportingStepArgs>,
		steps: &Vec<Box<dyn ReportingStep>>,
		dependencies: &ReportingGraphDependencies,
		context: &ReportingContext,
	) -> bool,
	pub build: fn(
		name: &'static str,
		kind: ReportingProductKind,
		args: Box<dyn ReportingStepArgs>,
		steps: &Vec<Box<dyn ReportingStep>>,
		dependencies: &ReportingGraphDependencies,
		context: &ReportingContext,
	) -> Box<dyn ReportingStep>,
}

// ------------------
// REPORTING PRODUCTS

/// Identifies a [ReportingProduct]
#[derive(Debug, Eq, Hash, PartialEq)]
pub struct ReportingProductId {
	pub name: &'static str,
	pub kind: ReportingProductKind,
	pub args: Box<dyn ReportingStepArgs>,
}

impl Display for ReportingProductId {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		f.write_fmt(format_args!("{}.{:?}({})", self.name, self.kind, self.args))
	}
}

/// Identifies a type of [ReportingProduct]
#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
pub enum ReportingProductKind {
	Transactions,
	BalancesAt,
	BalancesBetween,
	Generic,
}

/// Represents the result of a [ReportingStep]
pub enum ReportingProduct {
	Transactions(Transactions),
	BalancesAt(BalancesAt),
	BalancesBetween(BalancesBetween),
	Generic(Box<dyn GenericReportingProduct>),
}

/// Records a list of transactions generated by a [ReportingStep]
pub struct Transactions {}

/// Records cumulative account balances at a particular point in time
pub struct BalancesAt {
	pub balances: HashMap<String, QuantityInt>,
}

/// Records the total value of transactions in each account between two points in time
pub struct BalancesBetween {}

/// Represents a custom [ReportingProduct] generated by a [ReportingStep]
pub trait GenericReportingProduct {}

/// Convenience type mapping [ReportingProductId] to [ReportingProduct]
pub type ReportingProducts = HashMap<ReportingProductId, ReportingProduct>;

// ---------------
// REPORTING STEPS

/// Identifies a [ReportingStep]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct ReportingStepId {
	pub name: &'static str,
	pub product_kinds: &'static [ReportingProductKind],
	pub args: Box<dyn ReportingStepArgs>,
}

impl Display for ReportingStepId {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		f.write_fmt(format_args!(
			"{}{:?}({})",
			self.name, self.product_kinds, self.args
		))
	}
}

/// Represents a step in a reporting job
pub trait ReportingStep: Debug + Display + Downcast {
	/// Get the [ReportingStepId] for this [ReportingStep]
	fn id(&self) -> ReportingStepId;

	/// Return a list of statically defined dependencies for this [ReportingStep]
	#[allow(unused_variables)]
	fn requires(&self, context: &ReportingContext) -> Vec<ReportingProductId> {
		vec![]
	}

	/// Called when the [ReportingStep] is initialised in [super::calculator::steps_for_targets]
	#[allow(unused_variables)]
	fn init_graph(
		&self,
		steps: &Vec<Box<dyn ReportingStep>>,
		dependencies: &mut ReportingGraphDependencies,
		context: &ReportingContext,
	) {
	}

	/// Called when new [ReportingStep]s are initialised in [super::calculator::steps_for_targets]
	///
	/// This callback can be used to dynamically declare dependencies between [ReportingStep]s that are not known at initialisation.
	#[allow(unused_variables)]
	fn after_init_graph(
		&self,
		steps: &Vec<Box<dyn ReportingStep>>,
		dependencies: &mut ReportingGraphDependencies,
		context: &ReportingContext,
	) {
	}

	/// Called to generate the [ReportingProduct] for this [ReportingStep]
	#[allow(unused_variables)]
	fn execute(&self, context: &ReportingContext, products: &mut ReportingProducts) {
		todo!();
	}
}

downcast_rs::impl_downcast!(ReportingStep);

// ------------------------
// REPORTING STEP ARGUMENTS

/// Represents arguments to a [ReportingStep]
pub trait ReportingStepArgs: Debug + Display + Downcast + DynClone + DynEq + DynHash {}

downcast_rs::impl_downcast!(ReportingStepArgs);
dyn_clone::clone_trait_object!(ReportingStepArgs);
dyn_eq::eq_trait_object!(ReportingStepArgs);
dyn_hash::hash_trait_object!(ReportingStepArgs);

/// [ReportingStepArgs] implementation which takes no arguments
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct VoidArgs {}

impl ReportingStepArgs for VoidArgs {}

impl Display for VoidArgs {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		f.write_fmt(format_args!(""))
	}
}

/// [ReportingStepArgs] implementation which takes a single date
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct DateArgs {
	pub date: NaiveDate,
}

impl ReportingStepArgs for DateArgs {}

impl Display for DateArgs {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		f.write_fmt(format_args!("{}", self.date))
	}
}

/// [ReportingStepArgs] implementation which takes a date range
#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub struct DateStartDateEndArgs {
	pub date_start: NaiveDate,
	pub date_end: NaiveDate,
}

impl ReportingStepArgs for DateStartDateEndArgs {}

impl Display for DateStartDateEndArgs {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		f.write_fmt(format_args!("{}, {}", self.date_start, self.date_end))
	}
}
